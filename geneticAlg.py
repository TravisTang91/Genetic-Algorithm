from random import choices, sample, randrange, random, shuffle
import numpy as np

# Self-defined crossover
# def breeder(a, b):
#     o = []
#     for j in range(1,5):
#         swap = sample(range(len(a)), j*len(a)//5)
#         for i in swap:
#             a[i], b[i] = b[i], a[i]
#         o += [a[:], b[:]]
#     return o

# Position-based crossover(PBX)
# def breeder(a, b):
#     o = []
#     swap = sample(range(len(a)), len(a)//3)
#     for i in swap:
#             b[i] = a[i]
#     o += [b[:]]
#     return o

# #single-point crossover
def breeder(a, b):
    swap = sample(range(len(a)), 1)[0]
    o = [a[:swap]+b[swap:], b[:swap]+a[swap:]]
    return o

# multiple-points crossover
# def breeder(a, b):
#     swap = sample(range(len(a)), 2)
#     point1 = min(swap)
#     point2 = max(swap)
#     o = [a[:point1]+b[point1:point2]+a[point2:], b[:point1] + a[point1:point2] +b[point2:]]
#     return o


def mutator(a, randomer):
    t = randrange(len(a))
    a[t] = randomer(t)
    o = [a[:]]
    return o

nan = float('nan')

def optimize(generation, scorer=sum, breeder=breeder, mutator=mutator, randomer=random, minimize=False,
            iter=100, log=False):
    """
    Optimize objective function using Genetic Algorithm and Natural Selection
    
    Parameters
    ----------
    generation: The generation to be optimized. A generation is a set of initial
                x objects, usually random
    
    scorer: The objective function. The function is maximized during training. To
            minimize, set `minimize` to True. To mark some X-objects as invalid
            (or to define boundary), return NAN, like np.nan

    breeder: Define how breeding goes on between 2 generations. The default `ga.breeder`
             assumes X-objects to be lists and swaps random corresponding positions of
             them. The function should take two X-objects as input and return a list
             of next-generation X-objects

    mutator: Define how mutatiion goes on betwen 2 generations. The default `ga.mutator`
             assumes X-objects to be lists and replaces random positions of them with 
             random values generated by `random`. The function should take single
             X-objects as input and return a list of next-generation X-objects
    
    randomer: Random generator for `mutator` assuming X-objects are lists. The default
              `math.random` returns random reals in [0,1). The function should take no
              input and return random objects in the list X-object
              
    minimize: See `scorer`
    
    iter: Number of iterations
    
    log: Whether to return score log of the process. The log is a N by 2 array consisting
         of best (either highest or lowest) and average score of each iteration
    """
    print("---------------Optimizing----------------")
    print("-----------------------------------------")
    scores = []
    bestScore = 9e9
    converge  = 0
    while converge < iter:
        best = (min if minimize else max)(generation, key=scorer)
        score = scorer(best)
        if score < bestScore:
            bestScore = score
            print("Converge at electricity fee: ", np.round(bestScore, 2), "HKD")
            # print(generation[0])
            converge  = 0
        else:
            converge += 1
        if log:
            scores.append(scorer(best))
        newGeneration = [best]
        # breeding
        shuffle(generation)
        for i in range(0, len(generation)//2*2, 2):
            newGeneration += breeder(generation[i][:], generation[i+1][:])
        # mutation
        for i in generation:
            newGeneration += mutator(i[:], randomer)
        newGeneration = sorted(newGeneration, key=scorer)
        if minimize:
            generation = newGeneration[:len(generation)+1]
        else:
            generation = newGeneration[-len(generation)-1:]
    if minimize:
        generation = generation[0]
    else:
        generation = generation[-1]
    if log:
        return generation, scores
    else:
        return generation